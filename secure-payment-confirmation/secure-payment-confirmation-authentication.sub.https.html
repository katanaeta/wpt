<!DOCTYPE html>
<meta charset="utf-8">
<title>Test for the 'secure-payment-confirmation' payment method authentication</title>
<link rel="help" href="https://w3c.github.io/secure-payment-confirmation/sctn-authentication">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/resources/testdriver.js"></script>
<script src="/resources/testdriver-vendor.js"></script>
<script>
'use strict';

const details = {total:
    {label: 'Total', amount: {value: '0.01', currency: 'USD'}}};
const instrumentIcon = 'https://{{hosts[][www]}}:{{ports[https][0]}}/secure-payment-confirmation/troy.png';

/*
promise_test(() => {
  // The PaymentRequest constructor does no parsing of the 'data' blob for a
  // given payment method, so should not reject here.
  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: 'X',
        icon: instrumentIcon,
      },
    }
  }], details);
  // Empty credential ids should fail the 'steps to check if a payment should
  // be made' algorithm for SPC, which then causes show() to reject the (sole)
  // payment method with a NotSupportedError.
  return promise_rejects_js(NotSupportedError, request.show());
}, 'credentialIds must not be empty');

promise_test(() => {
  // The PaymentRequest constructor does no parsing of the 'data' blob for a
  // given payment method, so should not reject here.
  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [Uint8Array.from('x', c => c.charCodeAt(0))],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: 'this-is-not-an-origin',
      timeout: 60000,
      instrument: {
        displayName: 'X',
        icon: instrumentIcon,
      },
    }
  }], details);
  // An invalid payeeOrigin should fail the 'steps to check if a payment should
  // be made' algorithm for SPC, which then causes show() to reject the (sole)
  // payment method with a NotSupportedError.
  return promise_rejects_js(NotSupportedError, request.show());
}, 'payeeOrigin must be a valid origin');

promise_test(() => {
  // The PaymentRequest constructor does no parsing of the 'data' blob for a
  // given payment method, so should not reject here.
  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [Uint8Array.from('x', c => c.charCodeAt(0))],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: '',
        icon: instrumentIcon,
      },
    }
  }], details);
  // An empty displayName should fail the 'steps to check if a payment should
  // be made' algorithm for SPC, which then causes show() to reject the (sole)
  // payment method with a NotSupportedError.
  return promise_rejects_js(NotSupportedError, request.show());
}, 'instrument.displayName must be non-empty');

promise_test(() => {
  // The PaymentRequest constructor does no parsing of the 'data' blob for a
  // given payment method, so should not reject here.
  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [Uint8Array.from('x', c => c.charCodeAt(0))],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: 'X',
        // TODO: Make this a non-parseable data URL instead?
        icon: 'https://this-does-not-exist.test/icon.png',
      },
    }
  }], details);
  // An instrument icon that cannot be fetched should fail the 'steps to check
  // if a payment should be made' algorithm for SPC, which then causes show()
  // to reject the (sole) payment method with a NotSupportedError.
  return promise_rejects_js(NotSupportedError, request.show());
}, 'instrument.icon must be fetchable');
*/

const authenticatorOptions = {
  protocol: 'ctap2_1',
  transport: 'internal',
  hasResidentKey: true,
  hasUserVerification: true,
  isUserVerified: true,
};

async function createCredential(set_payment_extension=true) {
  const challengeBytes = new Uint8Array(16);
  window.crypto.getRandomValues(challengeBytes);

  const publicKey = {
    challenge: challengeBytes,
    rp: {
      name: 'Acme',
    },
    user: {
      id: new Uint8Array(16),
      name: 'jane.doe@example.com',
      displayName: 'Jane Doe',
    },
    pubKeyCredParams: [{
      type: 'public-key',
      alg: -7,  // 'ES256'
    }],
    authenticatorSelection: {
      userVerification: 'required',
      residentKey: 'required',
      authenticatorAttachment: 'platform',
    },
    timeout: 30000,
  };

  if (set_payment_extension) {
    publicKey.extensions = {
      payment: { isPayment: true },
    };
  }

  return navigator.credentials.create({publicKey});
}

promise_test(async t => {
  const authenticator = await window.test_driver.add_virtual_authenticator(
      authenticatorOptions);
  t.add_cleanup(() => {
    return window.test_driver.remove_virtual_authenticator(authenticator);
  });

  const credential = await createCredential();

  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [credential.rawId],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: 'X',
        icon: instrumentIcon,
      },
    }
  }], details);

  const responsePromise = request.show();

  await window.test_driver.accept_spc_transaction();

  const response = await responsePromise;
  await response.complete('success');

  const cred = response.details;
  // assert_equals(cred.id, credential.id);
  // assert_equals(cred.clientDataJSON.type, 'payment.get');
  // assert_equals(cred.clientDataJSON.challenge, challenge-from-above);
  // assert_equals(cred.clientDataJSON.origin, window.location.origin);  <-- TODO: test auth-in-iframe case
  // assert_equals(cred.clientDataJSON.crossOrigin, false);  <--- TODO: test crossOrigin case (RP != caller origin)
  // assert_equals(cred.clientDataJSON.payment.rp, window.location.origin);
  // assert_equals(cred.clientDataJSON.payment.topOrigin, window.location.origin);  <-- TODO: test auth-in-iframe case
  // assert_equals(cred.clientDataJSON.payment.payeeOrigin, origin-from-above);
  // assert_equals(cred.clientDataJSON.payment.total.value, details.total.amount.value);
  // assert_equals(cred.clientDataJSON.payment.total.currency, details.total.amount.currency);
  // assert_equals(cred.clientDataJSON.payment.instrument.icon, instrumentIcon);
  // assert_equals(cred.clientDataJSON.payment.instrument.displayName, displaynamefromabove);
  // verifySignature(cred);
}, 'Successful SPC call');

promise_test(async t => {
  const authenticator = await window.test_driver.add_virtual_authenticator(
      authenticatorOptions);
  t.add_cleanup(() => {
    return window.test_driver.remove_virtual_authenticator(authenticator);
  });

  const credential = await createCredential();

  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [credential.rawId],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: 'X',
        icon: instrumentIcon,
      },
    }
  }], details);

  const responsePromise = request.show();

  await window.test_driver.reject_spc_transaction();

  try {
    await responsePromise;
    assert_unreached();
  } catch (e) {
    console.log(e);
    assert_true(e instanceof DOMException);
  }
}, 'Rejected SPC call');
/*
promise_test(async t => {
  const authenticator = await window.test_driver.add_virtual_authenticator(
      authenticatorOptions);
  t.add_cleanup(() => {
    return window.test_driver.remove_virtual_authenticator(authenticator);
  });

  // We deliberately don't register a credential here.

  // Instruct the browser to accept the SPC transaction dialog, to make sure
  // that the call isn't rejected just because of this.
  await window.test_driver.set_secure_payment_confirmation_accepted(true);

  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [Uint8Array.from('non-existent-credential', c => c.charCodeAt(0))],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: 'X',
        icon: instrumentIcon,
      },
    }
  }], details);

  return promise_rejects_dom(NotAllowedError, request.show());
}, 'Mis-match SPC call');

promise_test(async t => {
  const authenticator = await window.test_driver.add_virtual_authenticator(
      authenticatorOptions);
  t.add_cleanup(() => {
    return window.test_driver.remove_virtual_authenticator(authenticator);
  });

  const credential = await createCredential(set_payment_extension=false);

  // Instruct the browser to accept the SPC transaction dialog, to make sure
  // that the call isn't rejected just because of this.
  await window.test_driver.set_secure_payment_confirmation_accepted(true);

  const request = new PaymentRequest([{
    supportedMethods: 'secure-payment-confirmation',
    data: {
      credentialIds: [credential.id],
      challenge: Uint8Array.from('x', c => c.charCodeAt(0)),
      payeeOrigin: window.location.origin,
      timeout: 60000,
      instrument: {
        displayName: 'X',
        icon: instrumentIcon,
      },
    }
  }], details);

  return promise_rejects_dom(NotAllowedError, request.show());
}, 'Can\'t use SPC with a pure webauthn credential');
*/
</script>
